<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Hands-on: Desenvolvi_ mento de Frameworks - parte 1 by br11</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Hands-on: Desenvolvi_ mento de Frameworks - parte 1</h1>
        <p class="header">Estrutura, Comportamento e Extensibilidade.</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/br11/swing-framework_hands-on/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/br11/swing-framework_hands-on/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/br11/swing-framework_hands-on">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/br11">br11</a></p>


      </header>
      <section>
        <p>Neste hand-on você partirá de uma aplicação que já tem uma tela (IHM) pronta. Você simulará o desenvolvimento das demais telas da aplicação. Visando demonstrar a atividade de componentização inserida no contexto de desenvolvimento de uma aplicação, a cada nova tela você inserirá melhorias à maneira implementá-las.</p>

<p>Siga atentamente as instruções contidas nas três seções a seguir antes de iniciar a execução dos exercícios.</p>

<p>Este documento também está disponível em <a href="https://docs.google.com/document/d/1IepxBa9vvOJwlnM5aoDLDMAF6H7GnCIwjKFk-1dvCKU/pub">https://docs.google.com/...</a></p>

<h3>
<a name="requisitos" class="anchor" href="#requisitos"><span class="octicon octicon-link"></span></a>Requisitos</h3>

<ul>
<li>Git</li>
<li>JDK 1.7.x</li>
<li>Maven 3.x</li>
<li>Eclipse Standard IDE</li>
</ul><h3>
<a name="prepara%C3%A7%C3%A3o" class="anchor" href="#prepara%C3%A7%C3%A3o"><span class="octicon octicon-link"></span></a>Preparação</h3>

<p>Executar os seguintes passos para baixar os fontes e gerar o projeto do Eclipse.</p>

<pre><code>&gt; mkdir hands-on
&gt; cd hands-on
&gt; git clone https://github.com/br11/swing-framework_hands-on.git
&gt; cd swing-framework_hands-on
&gt; mvn eclipse:clean eclipse:eclipse
</code></pre>

<p>Após executar os comandos acima, importe o projeto no eclipse.
Caso não queira usar Maven e Git você podera fazer o download e descompactar o arquivo .zip, criar um projeto no eclipse apontando para a pasta descompactada. No Eclipse, crie uma source folder apontando para <em>src/main/java</em>.</p>

<h3>
<a name="execu%C3%A7%C3%A3o" class="anchor" href="#execu%C3%A7%C3%A3o"><span class="octicon octicon-link"></span></a>Execução</h3>

<p>Edite o arquivo LoadUtil.java para disponibilizar a tela que será testada.
Execute a classe br.atech.workshop.bestpractices.app.Boot contida no projeto.
Informe o número da tela.
Preencha o campo nome e clique em um dos botões.</p>

<p><img src="https://lh5.googleusercontent.com/wHBK-j6LY40PMsCLXEi7mW_sJq5HVwL3ANRN0D9obYS9nXJ3wrlByniJ3_mhMWm5U4iL-HBXeIbm-UPwRBxiR8N_4z2kOc588TsnC8aUQ14xMe3rXGz53vQ6GM6-Xsyjsg" alt=""></p>

<p>Clique seguidas vezes até obter uma mensagem de erro. Desta forma você irá testar o tratamento de excessões.</p>

<h3>
<a name="exerc%C3%ADcios" class="anchor" href="#exerc%C3%ADcios"><span class="octicon octicon-link"></span></a>Exercícios</h3>

<p>É necessários que os exercício seja executados em sequência. Durante a codificação, aproveite para explorar o código fonte e analisar as alteração que estão sendo propostas. Sempre execute a aplicação após concluir cada exercício - siga as instruções descritas na sessão Execução.</p>

<p><br><strong>Exercício 1</strong>: Implementar uma tela Swing.</p>

<p><br><strong>Exercício 1.1</strong>: Implementar a ação do botão número 2.</p>

<pre><code>protected void addBtn2Listeners() {
    btn2.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent event) {
            try {
                resultfield.setText("");
                reset();
                resultfield.setText(app.feature2(namefield.getText()));
            } catch (AppException e) {
                e.printStackTrace();
                print("System Error");
            }
        }
    });
}
</code></pre>

<p><br><strong>Exercício 1.2</strong>: Implementar a ação do botão número 3.</p>

<pre><code>protected void addBtn3Listeners() {
    btn2.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent event) {
            try {
                resultfield.setText("");
                reset();
                resultfield.setText(app.feature3(namefield.getText()));
            } catch (AppException e) {
                e.printStackTrace();
                print("System Error");
            }
        }
    });
}
</code></pre>

<p><br><strong>Exercício 1.3</strong>: Limpar o resultado da execução anterior ao se editar o campo nome.</p>

<pre><code>        public void onChange(DocumentEvent e) {
            resultfield.setText("");
            reset();
        }
</code></pre>

<p>Não se esqueça de editar o arquivo LoadUtil.java para disponibilizar a tela 1.</p>

<p><br><strong>Exercício 2</strong>: Melhorar o tratamento de exceção.</p>

<p><br><strong>Exercício 2.1</strong>: Tratar as diferentes exceções.</p>

<pre><code>    if (err instanceof AppException) {
        return "Não foi possível processar sua requisição.";
    } else if (err instanceof RuntimeException) {
        return "Falha interna. Notifique o administrador do sistema.";
    } else {
        return "Falha de processamento.";
    }
</code></pre>

<p><br><strong>Exercício 2.2</strong>: Instanciar o ExceptionHandler.</p>

<pre><code>private ExceptionHandler exHandler = new ExceptionHandler(this);
</code></pre>

<p><br><strong>Exercício 2.3</strong>: Usando o ExceptionHandler.</p>

<pre><code>        @Override
        public void actionPerformed(ActionEvent event) {
            try {
                reset();
                resultfield.setText(app.feature3(namefield.getText()));
            } catch (AppException e) {
                exHandler.handle(e);
            }
        }
</code></pre>

<p><br><strong>Exercício 2.4</strong>: Limpar os campos ao editar o campo nome.</p>

<pre><code>        public void onChange(DocumentEvent e) {
            reset();
        }
</code></pre>

<p><br><strong>Exercício 2.5</strong>: Implementar toda lógica de limpeza de campos no método reset().</p>

<pre><code>@Override
public void reset() {
    resultfield.setText("");
    super.reset();
}
</code></pre>

<p><br><strong>Exercício 3</strong>: Eliminar duplicação de código através de pequenas mudanças.</p>

<p><br><strong>Exercício 3.1</strong>: Implementar um ActionListener para servir de base para implementação de todas as ações de tela.</p>

<pre><code>@Override
public final void actionPerformed(ActionEvent event) {
    try {
        gui.reset();
        onAction();
    } catch (AppException e) {
        exHandler.handle(e);
    }
}
</code></pre>

<p><br><strong>Exercício 3.2</strong>: Implementar a ação do botão número 3 baseada no AbstractActionListener.</p>

<pre><code>    btn3.addActionListener(new AbstractActionListener(this) {
        /*
         * (non-Javadoc)
         * 
         * @see
         * br.atech.workshop.duplicateCode.gui.Gui3.Gui3Listener#onAction()
         */
        @Override
        protected void onAction() throws AppException {
            resultfield.setText(app.feature3(namefield.getText()));
        }
    });
</code></pre>

<p><br><strong>Exercício 3.3</strong>: Implementar a ação de limpar painel de mensagens quando um campo é editado.</p>

<pre><code>/**
 * 
 * @param e
 */
public void onChange(DocumentEvent e) {
    gui.reset();
}
</code></pre>

<p><br><strong>Exercício 3.4</strong>: Aplicar a ação de limpar o painel de mensagens ao campo nome.</p>

<pre><code>protected void addNamefieldListeners() {
    namefield.getDocument().addDocumentListener(
            new DefaultDocumentListener(this));
}
</code></pre>

<p><br><strong>Exercício 4</strong>: Implementar um Framework de tela.</p>

<p><br><strong>Exercício 4.1</strong>: Implementar um comportamento padrão para todas as ações.</p>

<pre><code>@Override
public void onAction(ActionEvent event) throws Exception {
    getGui().reset();
    super.onAction(event);
}
</code></pre>

<p><br><strong>Exercício 4.2</strong>: Ativar os ActionListeners ao exibir a tela. </p>

<pre><code>@Override
public void show() {
    actionListener.activate();
    super.show();
}
</code></pre>

<p><br><strong>Exercício 4.3</strong>: O painel de mensagens deve ser limpo quando qualquer campo da tela é editado.</p>

<pre><code>protected void anyOnChange(DocumentEvent event) throws AppException {
    reset();
}
</code></pre>

<p><br><strong>Exercício 4.4</strong>: Usar o Framework para implementar a Gui4.</p>

<pre><code>public class Gui4 extends StandardGui {
</code></pre>

<p><br><strong>Exercício 4.5</strong>: Implementa a ação do botão número 2.</p>

<pre><code>protected void btn2OnClick(ActionEvent event) throws AppException {
    resultfield.setText(app.feature2(namefield.getText()));
}
</code></pre>

<p><br><strong>Exercício 4.6</strong>: Implementa a ação do botão número 3.</p>

<pre><code>protected void btn3OnClick(ActionEvent event) throws AppException {
    resultfield.setText(app.feature3(namefield.getText()));
}
</code></pre>

<p><br><strong>Exercício 4.7</strong>: Limpar também o resultado da última execução.</p>

<pre><code>@Override
public void reset() {
    resultfield.setText("");
    super.reset();
}
</code></pre>

<p><br><strong>Exercício 5</strong>: Tornar nosso Framework extensível criando facilidades para acrescentar, modificar e/ou sobrescrever os comportamentos da tela.</p>

<p><br><strong>Exercício 5.1</strong>: Implementa um ponto de extensão no fechamento da tela.</p>

<pre><code>@Override
public void windowClosing(WindowEvent e) {
    gui.hide();
}
</code></pre>

<p><br><strong>Exercício 5.2</strong>: Habilitando o ponto de extensão criado no exercício anterior.</p>

<pre><code>public ExtensibleGui() {
    getFrame().addWindowListener(new CloseListener(this));
}
</code></pre>

<p><br><strong>Exercício 5.3</strong>: Habilitando os pontos de extensão de abertura de tela.</p>

<pre><code>@Override
public final void show() {
    beforeShow();
    onShow();
    afterShow();
}
</code></pre>

<p><br><strong>Exercício 5.4</strong>: Habilitando os pontos de extensão de fechamento de tela.</p>

<pre><code>@Override
public final void hide() {
    beforeHide();
    onHide();
    afterHide();
}
</code></pre>

<p><br><strong>Exercício 5.5</strong>: Implementar a possíbilidade de alterar o comportamento padrão da tela.</p>

<pre><code>public void setActionListener(
        StandardEventListener&lt;? extends ExtensibleGui&gt; actionListener) {
    if (this.actionListener != null) {
        this.actionListener.deactivate();
    }
    this.actionListener = actionListener;
}
</code></pre>

<p><br><strong>Exercício 5.6</strong>: Usar o Framework para implementar a Gui5.</p>

<pre><code>public class Gui5 extends ExtensibleGui {
</code></pre>

<p><br><strong>Exercício 5.7</strong>: Aproveitar o ponto de extensão para customizar o comportamento da tela.</p>

<pre><code>@Override
protected void afterHide() {
    super.afterHide();
    JOptionPane.showMessageDialog(null, "Good bye!");
}
</code></pre>

<p><br><strong>Exercício 6</strong>: Neste exercício veremos o quão complexo pode ser implementar o comportamento, mesmo que o framework dê suporte à extensão.</p>

<p><br><strong>Exercício 6.1</strong>: Vamos aproveitar para tornar padrão o comportamento de mudar o cursor para “aguarde” ao clicar nos botões.</p>

<p>ExtendedEventListener.java</p>

<pre><code>@Override
public void onAction(ActionEvent event) throws Exception {
    try {
        getGui().getFrame().setCursor(
                Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        super.onAction(event);
    } finally {
        getGui().getFrame().setCursor(
                Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
    }
}
</code></pre>

<p><br><strong>Exercício 6.2</strong>: Toda tela deve exibir uma mensagem de despedida ao ser fechada.</p>

<p>ExtendedGui.java</p>

<pre><code>@Override
protected void afterHide() {
    super.afterHide();
    JOptionPane.showMessageDialog(null, "Tchau!");
}
</code></pre>

<p><br><strong>Exercício 6.3</strong>: Simplificar a Implementação de confirmações.</p>

<p>ExtendedGui.java</p>

<pre><code>protected boolean confirm(String message) {
    return JOptionPane.showConfirmDialog(getFrame(), message,
            "Confirmação", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION;
}
</code></pre>

<p><br><strong>Exercício 6.4</strong>: Variável necessária para controle da confirmação</p>

<p>Gui6.java</p>

<pre><code>private boolean confirm = false;
</code></pre>

<p><br><strong>Exercício 6.5</strong>: Desabilitar o fechamento instantâneo da tela 6.</p>

<p>Gui6.java</p>

<pre><code>getFrame().setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
</code></pre>

<p><br><strong>Exercício 6.6</strong>: Solicitar confirmação antes de fechar a tela 6.</p>

<p>Gui6.java</p>

<pre><code>protected void beforeHide() {
    confirm = confirm("Deseja realmente encerrar?");
    if (!confirm) {
        return;
    }

    super.beforeHide();
}
</code></pre>

<p><br><strong>Exercício 6.7</strong>: Fechar a tela caso o usuário tenha confirmado.</p>

<p>Gui6.java</p>

<pre><code>@Override
protected void onHide() {
    if (!confirm) {
        return;
    }

    super.onHide();

    getFrame().dispose();
}
</code></pre>

<p><br><strong>Exercício 7</strong>: Para não tornar o framework uma dificuldade em vez de uma ajuda, vamos calibrá-lo para um perfeito ajuste às nossas necessidades.</p>

<p><br><strong>Exercício 7.1</strong>: Implemente um signal de abortar execução.</p>

<p>AbortSignal.java</p>

<pre><code>public class AbortSignal extends RuntimeException {
    private static final long serialVersionUID = 1L;
}
</code></pre>

<p><br><strong>Exercício 7.2</strong>: Ao receber um signal de abortar nada é feito senão retornar imediatamente. A implementação é feita de maneira a isolar o código do resto do framework.</p>

<p>AdvancedExceptionHandler.java</p>

<pre><code>@Override
public void handle(Throwable t) {
    if (t instanceof AbortSignal) {
        return;
    }
    super.handle(t);
}
</code></pre>

<p><br><strong>Exercício 7.3</strong>: Aplicar o novo componente à tela.</p>

<p>AdvancedGui.java</p>

<pre><code>public AdvancedGui() {
    setActionListener(new ExtendedEventListener&lt;&gt;(this,
            new AdvancedExceptionHandler(this)));
}
</code></pre>

<p><br><strong>Exercício 7.4</strong>: Criar um método para isolar a lógica e simplificar o reuso.</p>

<p>AdvancedGui.java</p>

<pre><code>protected void abort() {
    throw new AbortSignal();
}
</code></pre>

<p><br><strong>Exercício 7.5</strong>: Implementar a Gui7 a partir do framework.</p>

<p>Gui7.java</p>

<pre><code>public class Gui7 extends AdvancedGui {
</code></pre>

<p><br><strong>Exercício 7.6</strong>: Solicitar confirmação antes de fechar a tela 7.</p>

<p>Gui7.java</p>

<pre><code>@Override
protected void beforeHide() {
    if (!confirm("Deseja realmente encerrar?")) {
        abort();
    }

    super.beforeHide();
}
</code></pre>

<p><br><strong>Exercício 8</strong>: Neste exercício iremos tornar padrão a todos comportamentos que viemos implementando ao longo o tempo nas diferentes telas.Assim todas os botões deverão mudar o cursor para “aguarde” durante o processamento; toda tela deve solicitar confirmação de fechamento e exibir mensagem de despedida.</p>

<p><br><strong>Exercício 8.1</strong>: Vamos calibrar o framework para encarar esse novo desafio. Para tal vamos preparemos uma matriz para facilitar a implementação das novas telas.</p>

<p>SimpleGui.java</p>

<pre><code>@Override
protected void beforeHide() {
    if (!confirm("Deseja realmente encerrar?")) {
        abort();
    }
    super.beforeHide();
}
</code></pre>

<p><br><strong>Exercício 8.2</strong>: Implementar a tela 8 no novo padrão de comportamento.</p>

<p>Gui8.java</p>

<pre><code>@Override
public void reset() {
    resultfield.setText("");
    super.reset();
}
</code></pre>

<p><br><strong>Exercício 8.3</strong>: Agora traremos as telas pré-existentes para o novo padrão.</p>

<p>Gui4.java</p>

<pre><code>public class Gui4 extends SimpleGui {
</code></pre>

<p>Veja os arquivos Gui4a.java e Gui1a.java para comparar a solução componentizada e a solução brute-force.</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
